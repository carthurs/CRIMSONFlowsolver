#include "pureZeroDDriver.hxx"

void PureZeroDDriver::init()
{
	m_timestepNumber = 0;

	double oneResistanceToGiveEachResistor = 0.001;
	double elastanceToGiveVolumeTrackingPressureChamber = 3000.0;
	double initialDomainPressure = 133.3 * 80; // 80 mmHg
	int negativeIndexForNetlistThatReplaces3DDomain = -1;
	m_zeroDDomainLPN = boost::interprocess::unique_ptr<Netlist3DDomainReplacement> (new Netlist3DDomainReplacement(negativeIndexForNetlistThatReplaces3DDomain, oneResistanceToGiveEachResistor, elastanceToGiveVolumeTrackingPressureChamber, initialDomainPressure));

	assert(boundaryConditionManager_instance->getNumberOfNetlistSurfaces() > 0);
	// Arrays to park the boundary pressures and flows generated by the zero-D replacement for the 3D domain
	// We do this so we can recycle the code that expects boundary flow/pressure pointers from Fortran from the 3D domain case.
	mp_interfaceFlows = new double[boundaryConditionManager_instance->getNumberOfNetlistSurfaces()];
	mp_interfacePressures = new double[boundaryConditionManager_instance->getNumberOfNetlistSurfaces()];

	// Initialise to zero:
	for (int ii=0; ii<boundaryConditionManager_instance->getNumberOfNetlistSurfaces(); ii++)
	{
		mp_interfaceFlows[ii] = 0.0;
		mp_interfacePressures[ii] = 0.0;
	}

	// Give the boundary conditions the pointers to the boundary pressures and flows.
	// We do this like this because it mirrors the way the Fortran 3D domain would give the boundary
	// conditions their pointers to boundary pressures and flows.
	boundaryConditionManager_instance->setZeroDDomainReplacementPressuresAndFlows(mp_interfacePressures,mp_interfaceFlows);

	m_zeroDDomainLPN->initialiseModel();
}

void PureZeroDDriver::iter_init()
{
	m_zeroDDomainLPN->initialiseAtStartOfTimestep();
}

void PureZeroDDriver::iter_step()
{
	// Also need to actually solve the boundary conditions etc. here!

	m_pressuresOrFlowsAtBoundaries = boundaryConditionManager_instance->getBoundaryPressuresOrFlows_zeroDDomainReplacement(m_timestepNumber);
	m_zeroDDomainLPN->setFlowOrPressurePrescriptionsFromNetlistBoundaryConditions(m_pressuresOrFlowsAtBoundaries);
	m_zeroDDomainLPN->solveSystem(m_timestepNumber);

	std::vector<double> boundaryPressures = m_zeroDDomainLPN->getBoundaryPressures();
	std::vector<double> boundaryFlows = m_zeroDDomainLPN->getBoundaryFlows();
	placePressuresAndFlowsInStorageArrays(boundaryPressures, boundaryFlows);

}

void PureZeroDDriver::iter_finalize()
{
	m_zeroDDomainLPN->updateLPN();
	m_zeroDDomainLPN->finalizeLPNAtEndOfTimestep();
	m_timestepNumber++;
}

void PureZeroDDriver::finalize()
{
	delete[] mp_interfaceFlows;
	delete[] mp_interfacePressures;
}

void PureZeroDDriver::placePressuresAndFlowsInStorageArrays(std::vector<double> boundaryPressures, std::vector<double> boundaryFlows)
{
	for (int boundaryConditionIndex = 0; boundaryConditionIndex < boundaryConditionManager_instance->getNumberOfNetlistSurfaces(); boundaryConditionIndex++)
	{
		mp_interfaceFlows[boundaryConditionIndex] = boundaryFlows.at(boundaryConditionIndex);
		mp_interfacePressures[boundaryConditionIndex] = boundaryPressures.at(boundaryConditionIndex);
	}
}